name: 本地编译iStoreOS-XGP（镜像版+虚拟环境修复）

on:
  workflow_dispatch:
  push:
    branches: [ main ]
    paths:
      - '.github/workflows/local-build-final.yml'
      - 'xgp-qmodem.config'
      - 'files/**'

jobs:
  local-build:
    runs-on: self-hosted
    env:
      TARGET_PLATFORM: rockchip
      TARGET_SUBPLATFORM: rk35xx
      FIRMWARE_DIST: istoreos
      ISTOREOS_BRANCH: "istoreos-24.10"
      LOCAL_BUILD_DIR: "${{ github.workspace }}/build"
      VENV_PATH: "${LOCAL_BUILD_DIR}/python-venv"  # 虚拟环境路径
      GITHUB_MIRROR: "https://bgithub.xyz"

    steps:
      - name: 0. 配置GitHub镜像（全局替换）
        run: |
          git config --global url."${{ env.GITHUB_MIRROR }}/".insteadOf "https://github.com/"
          echo "当前git全局镜像配置："
          git config --global --get-regexp url.*.insteadOf

      - name: 1. 拉取仓库代码（通过镜像）
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: 2. 系统依赖+Python虚拟环境配置（强化创建逻辑）
        run: |
          echo "===== 安装系统基础依赖 ====="
          REQUIRED_PACKAGES="build-essential flex bison g++ gawk gcc-multilib \
            gettext git libncurses5-dev libssl-dev libelf-dev python3 python3-pip \
            python3-venv rsync unzip wget zlib1g-dev quilt u-boot-tools squashfs-tools \
            meson ninja-build cmake device-tree-compiler liblz4-tool"

          for pkg in $REQUIRED_PACKAGES; do
            if ! dpkg -l | grep -q "$pkg"; then
              echo "安装缺失依赖：$pkg"
              sudo apt update -y || sudo apt update -y
              sudo apt install -y "$pkg" || {
                echo "ERROR: 安装 $pkg 失败！"
                exit 1
              }
            fi
          done

          # 验证python3-venv是否安装（虚拟环境依赖）
          echo "===== 验证python3-venv是否可用 ====="
          if ! dpkg -l | grep -q "python3-venv"; then
            echo "ERROR: python3-venv未安装，无法创建虚拟环境！"
            sudo apt install -y python3-venv --reinstall || exit 1
          fi

          # 关键：确保虚拟环境父目录存在且有写入权限
          echo "===== 准备虚拟环境目录 ====="
          echo "LOCAL_BUILD_DIR: ${{ env.LOCAL_BUILD_DIR }}"
          echo "VENV_PATH: ${{ env.VENV_PATH }}"
          # 创建父目录（避免目录不存在导致创建失败）
          mkdir -p "$(dirname ${{ env.VENV_PATH }})"
          # 检查权限（确保当前用户可写）
          if [ ! -w "$(dirname ${{ env.VENV_PATH }})" ]; then
            echo "ERROR: 目录 $(dirname ${{ env.VENV_PATH }}) 无写入权限！"
            sudo chown -R $USER:$USER "$(dirname ${{ env.VENV_PATH }})" || exit 1
          fi

          # 创建虚拟环境（带详细日志）
          echo "===== 创建Python虚拟环境 ====="
          if [ -d "${{ env.VENV_PATH }}" ]; then
            echo "清理旧虚拟环境..."
            rm -rf "${{ env.VENV_PATH }}"
          fi
          # 显式指定python3路径，避免版本混淆
          /usr/bin/python3 -m venv "${{ env.VENV_PATH }}" --verbose || {
            echo "ERROR: 虚拟环境创建失败！检查python3-venv是否安装或目录权限"
            exit 1
          }

          # 强制验证虚拟环境是否创建成功（核心修复点）
          echo "===== 验证虚拟环境 ====="
          if [ ! -f "${{ env.VENV_PATH }}/bin/activate" ]; then
            echo "ERROR: 虚拟环境激活脚本不存在！路径：${{ env.VENV_PATH }}/bin/activate"
            echo "可能原因：目录权限不足、python3-venv未安装、磁盘空间不足"
            # 输出目录结构辅助排查
            ls -ld "$(dirname ${{ env.VENV_PATH }})"
            ls -l "${{ env.VENV_PATH }}" 2>/dev/null || echo "虚拟环境目录不存在"
            exit 1
          fi

          # 安装Python依赖
          echo "===== 安装Python依赖 ====="
          source "${{ env.VENV_PATH }}/bin/activate" || {
            echo "ERROR: 激活虚拟环境失败！"
            exit 1
          }
          if ! python3 -c "import elftools" &> /dev/null; then
            pip install pyelftools --upgrade || exit 1
          fi
          deactivate

          echo "===== 验证核心工具 ====="
          REQUIRED_TOOLS="gcc make python3 git wget unzip mksquashfs"
          for tool in $REQUIRED_TOOLS; do
            if ! command -v $tool &> /dev/null; then
              echo "ERROR: 核心工具 $tool 未安装！"
              exit 1
            fi
          done

      - name: 3. 缓存编译资源
        uses: actions/cache@v3
        with:
          path: |
            ${{ env.LOCAL_BUILD_DIR }}/${{ env.FIRMWARE_DIST }}/dl
            ${{ env.LOCAL_BUILD_DIR }}/${{ env.FIRMWARE_DIST }}/feeds
          key: ${{ runner.os }}-istoreos-${{ env.ISTOREOS_BRANCH }}-${{ hashFiles('xgp-qmodem.config') }}
          restore-keys: |
            ${{ runner.os }}-istoreos-${{ env.ISTOREOS_BRANCH }}-

      - name: 4. 克隆/更新iStoreOS稳定分支（使用镜像）
        run: |
          mkdir -p ${{ env.LOCAL_BUILD_DIR }}
          cd ${{ env.LOCAL_BUILD_DIR }}

          if [ ! -d "${{ env.FIRMWARE_DIST }}" ]; then
            git clone "${{ env.GITHUB_MIRROR }}/istoreos/istoreos.git" ${{ env.FIRMWARE_DIST }} || {
              echo "ERROR: 镜像克隆失败！"
              exit 1
            }
          fi
          cd ${{ env.FIRMWARE_DIST }}
          git remote set-url origin "${{ env.GITHUB_MIRROR }}/istoreos/istoreos.git"
          git checkout ${{ env.ISTOREOS_BRANCH }}
          git pull || exit 1

          echo "当前分支：$(git branch --show-current)"

      - name: 5. 同步软件源（QModem使用镜像）
        run: |
          cd ${{ env.LOCAL_BUILD_DIR }}/${{ env.FIRMWARE_DIST }}
          sed -i 's#https://downloads.openwrt.org#https://mirrors.ustc.edu.cn/openwrt#g' feeds.conf.default
          sed -i 's#https://mirrors.cernet.edu.cn#https://mirrors.ustc.edu.cn#g' feeds.conf.default

          sed -i '/qmodem/d' feeds.conf.default
          echo "src-git qmodem ${{ env.GITHUB_MIRROR }}/FUjr/QModem.git" >> feeds.conf.default

          ./scripts/feeds update -a || exit 1
          ./scripts/feeds install -a -f

      - name: 6. 导入设备配置文件
        run: |
          cd ${{ env.LOCAL_BUILD_DIR }}/${{ env.FIRMWARE_DIST }}
          cp ${{ github.workspace }}/xgp-qmodem.config .config
          make defconfig

          if ! grep -q "CONFIG_TARGET_rockchip=y" .config; then
            echo "ERROR: 平台配置错误！"
            exit 1
          fi
          if ! grep -q "CONFIG_PACKAGE_luci-app-qmodem=y" .config; then
            echo "ERROR: QModem未启用！"
            exit 1
          fi

      - name: 7. 本地多核编译（激活前再次验证虚拟环境）
        run: |
          cd ${{ env.LOCAL_BUILD_DIR }}/${{ env.FIRMWARE_DIST }}

          # 再次验证虚拟环境是否存在（双重保险）
          echo "===== 再次验证虚拟环境 ====="
          if [ ! -f "${{ env.VENV_PATH }}/bin/activate" ]; then
            echo "ERROR: 虚拟环境激活脚本仍不存在！路径：${{ env.VENV_PATH }}/bin/activate"
            exit 1
          fi

          # 激活虚拟环境
          source "${{ env.VENV_PATH }}/bin/activate" || {
            echo "ERROR: 激活虚拟环境失败！"
            exit 1
          }
          if [ "$(which python3)" != "${{ env.VENV_PATH }}/bin/python3" ]; then
            echo "ERROR: 虚拟环境激活异常！当前python3路径：$(which python3)"
            exit 1
          fi

          CPU_CORES=$(nproc)
          echo "使用 $CPU_CORES 核心编译..."

          timeout 180m bash -c "
            make -j$CPU_CORES V=m 2>&1 | tee build.log &
            PID=\$!
            while kill -0 \$PID 2>/dev/null; do
              echo \"===== 编译中（$(date +%H:%M:%S)）=====\"
              grep -E \"Compiling|Linking|Installing\" build.log | tail -5
              sleep 600
            done
            wait \$PID
          "

          deactivate

          FIRMWARE_DIR="bin/targets/$TARGET_PLATFORM/$TARGET_SUBPLATFORM"
          if [ ! -d "$FIRMWARE_DIR" ] || [ -z "$(ls $FIRMWARE_DIR/*.sysupgrade.bin 2>/dev/null)" ]; then
            echo "ERROR: 编译失败！最后1000行日志："
            cat build.log | tail -1000
            exit 1
          fi
          echo "固件编译成功！"

      - name: 8. 打包产物
        run: |
          LOCAL_OUTPUT="${{ github.workspace }}/local-firmware"
          mkdir -p $LOCAL_OUTPUT
          REMOTE_OUTPUT="${{ env.LOCAL_BUILD_DIR }}/output"
          mkdir -p $REMOTE_OUTPUT

          FIRMWARE_DIR="${{ env.LOCAL_BUILD_DIR }}/${{ env.FIRMWARE_DIST }}/bin/targets/$TARGET_PLATFORM/$TARGET_SUBPLATFORM"
          cp $FIRMWARE_DIR/*.sysupgrade.bin $LOCAL_OUTPUT/
          cp $FIRMWARE_DIR/*.factory.img $LOCAL_OUTPUT/ 2>/dev/null
          cp ${{ env.LOCAL_BUILD_DIR }}/${{ env.FIRMWARE_DIST }}/.config $LOCAL_OUTPUT/final_config.config
          cp ${{ env.LOCAL_BUILD_DIR }}/${{ env.FIRMWARE_DIST }}/build.log $LOCAL_OUTPUT/build_log.txt

          cp -r $LOCAL_OUTPUT/* $REMOTE_OUTPUT/
          echo "本地产物路径：$LOCAL_OUTPUT"
          ls -l $LOCAL_OUTPUT

      - name: 9. 上传产物到GitHub
        uses: actions/upload-artifact@v4
        with:
          name: istoreos-local-mirror
          path: ${{ env.LOCAL_BUILD_DIR }}/output/
          retention-days: 30
